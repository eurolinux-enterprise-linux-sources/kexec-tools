From 9eb5a31bc2d7f6af88459b89c414fe144e7491f8 Mon Sep 17 00:00:00 2001
From: Kazuhito Hagio <k-hagio@ab.jp.nec.com>
Date: Thu, 8 Nov 2018 14:26:43 -0500
Subject: [PATCH] [PATCH] Prepare paddr_to_vaddr() for arch-specific p2v conversion

Currently, conversion from physical address to virtual address in
--mem-usage option is "paddr + PAGE_OFFSET", which was written for
x86_64, but it's not suitable especially for arm64.

This patch introduces paddr_to_vaddr() macro to get prepared for
arch-specific physical to virtual conversion.

Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
Signed-off-by: Kazuhito Hagio <k-hagio@ab.jp.nec.com>
---
 elf_info.c     |  7 ++++---
 makedumpfile.h | 11 +++++++++++
 2 files changed, 15 insertions(+), 3 deletions(-)

diff --git a/makedumpfile-1.6.2/elf_info.c b/makedumpfile-1.6.2/elf_info.c
index 711601a170c7..1d33e96684b6 100644
--- a/makedumpfile-1.6.2/elf_info.c
+++ b/makedumpfile-1.6.2/elf_info.c
@@ -372,7 +372,7 @@ int set_kcore_vmcoreinfo(uint64_t vmcoreinfo_addr, uint64_t vmcoreinfo_len)
	off_t offset_desc;

	offset = UNINITIALIZED;
-	kvaddr = (ulong)vmcoreinfo_addr + PAGE_OFFSET;
+	kvaddr = paddr_to_vaddr(vmcoreinfo_addr);

	for (i = 0; i < num_pt_loads; ++i) {
		struct pt_load_segment *p = &pt_loads[i];
@@ -810,10 +810,11 @@ static int exclude_segment(struct pt_load_segment **pt_loads,
	int i, j, tidx = -1;
	unsigned long long	vstart, vend, kvstart, kvend;
	struct pt_load_segment temp_seg = {0};
-	kvstart = (ulong)start + PAGE_OFFSET;
-	kvend = (ulong)end + PAGE_OFFSET;
	unsigned long size;

+	kvstart = paddr_to_vaddr(start);
+	kvend = paddr_to_vaddr(end);
+
	for (i = 0; i < (*num_pt_loads); i++) {
		vstart = (*pt_loads)[i].virt_start;
		vend = (*pt_loads)[i].virt_end;
diff --git a/makedumpfile-1.6.2/makedumpfile.h b/makedumpfile-1.6.2/makedumpfile.h
index 5f7a1dcf3b2f..010a9ce302bd 100644
--- a/makedumpfile-1.6.2/makedumpfile.h
+++ b/makedumpfile-1.6.2/makedumpfile.h
@@ -929,6 +929,8 @@ typedef unsigned long pgd_t;
 static inline int stub_true() { return TRUE; }
 static inline int stub_true_ul(unsigned long x) { return TRUE; }
 static inline int stub_false() { return FALSE; }
+#define paddr_to_vaddr_general(X) ((X) + PAGE_OFFSET)
+
 #ifdef __aarch64__
 int get_phys_base_arm64(void);
 int get_machdep_info_arm64(void);
@@ -938,6 +940,7 @@ int get_xen_basic_info_arm64(void);
 int get_xen_info_arm64(void);
 #define find_vmemmap()		stub_false()
 #define vaddr_to_paddr(X)	vaddr_to_paddr_arm64(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define get_phys_base()		get_phys_base_arm64()
 #define get_machdep_info()	get_machdep_info_arm64()
 #define get_versiondep_info()	get_versiondep_info_arm64()
@@ -958,6 +961,7 @@ unsigned long long vaddr_to_paddr_arm(unsigned long vaddr);
 #define get_versiondep_info()	stub_true()
 #define get_kaslr_offset(X)	stub_false()
 #define vaddr_to_paddr(X)	vaddr_to_paddr_arm(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define is_phys_addr(X)		stub_true_ul(X)
 #define arch_crashkernel_mem_size()	stub_false()
 #endif /* arm */
@@ -972,6 +976,7 @@ unsigned long long vaddr_to_paddr_x86(unsigned long vaddr);
 #define get_versiondep_info()	get_versiondep_info_x86()
 #define get_kaslr_offset(X)	stub_false()
 #define vaddr_to_paddr(X)	vaddr_to_paddr_x86(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define is_phys_addr(X)		stub_true_ul(X)
 #define arch_crashkernel_mem_size()	stub_false()
 #endif /* x86 */
@@ -989,6 +994,7 @@ unsigned long long vtop4_x86_64_pagetable(unsigned long vaddr, unsigned long pag
 #define get_versiondep_info()	get_versiondep_info_x86_64()
 #define get_kaslr_offset(X)	get_kaslr_offset_x86_64(X)
 #define vaddr_to_paddr(X)	vtop4_x86_64(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define is_phys_addr(X)		stub_true_ul(X)
 #define arch_crashkernel_mem_size()	stub_false()
 #endif /* x86_64 */
@@ -1004,6 +1010,7 @@ int arch_crashkernel_mem_size_ppc64(void);
 #define get_versiondep_info()	get_versiondep_info_ppc64()
 #define get_kaslr_offset(X)	stub_false()
 #define vaddr_to_paddr(X)	vaddr_to_paddr_ppc64(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define is_phys_addr(X)		stub_true_ul(X)
 #define arch_crashkernel_mem_size()	arch_crashkernel_mem_size_ppc64()
 #endif          /* powerpc64 */
@@ -1017,6 +1024,7 @@ unsigned long long vaddr_to_paddr_ppc(unsigned long vaddr);
 #define get_versiondep_info()	stub_true()
 #define get_kaslr_offset(X)	stub_false()
 #define vaddr_to_paddr(X)	vaddr_to_paddr_ppc(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define is_phys_addr(X)		stub_true_ul(X)
 #define arch_crashkernel_mem_size()	stub_false()
 #endif          /* powerpc32 */
@@ -1031,6 +1039,7 @@ int is_iomem_phys_addr_s390x(unsigned long addr);
 #define get_versiondep_info()	stub_true()
 #define get_kaslr_offset(X)	stub_false()
 #define vaddr_to_paddr(X)	vaddr_to_paddr_s390x(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define is_phys_addr(X)		is_iomem_phys_addr_s390x(X)
 #define arch_crashkernel_mem_size()	stub_false()
 #endif          /* s390x */
@@ -1045,6 +1054,7 @@ unsigned long long vaddr_to_paddr_ia64(unsigned long vaddr);
 #define get_versiondep_info()	stub_true()
 #define get_kaslr_offset(X)	stub_false()
 #define vaddr_to_paddr(X)	vaddr_to_paddr_ia64(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define VADDR_REGION(X)		(((unsigned long)(X)) >> REGION_SHIFT)
 #define is_phys_addr(X)		stub_true_ul(X)
 #define arch_crashkernel_mem_size()	stub_false()
@@ -1059,6 +1069,7 @@ unsigned long long vaddr_to_paddr_sparc64(unsigned long vaddr);
 #define get_phys_base()         get_phys_base_sparc64()
 #define get_versiondep_info()   get_versiondep_info_sparc64()
 #define vaddr_to_paddr(X)       vaddr_to_paddr_sparc64(X)
+#define paddr_to_vaddr(X)	paddr_to_vaddr_general(X)
 #define is_phys_addr(X)		stub_true_ul(X)
 #define arch_crashkernel_mem_size()	stub_false()
 #endif		/* sparc64 */
--
2.7.4
